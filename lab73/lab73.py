def resolve(current: list, clause: list):
	# current and clause are in the form of a list
	# for example [443, -442, etc] and [521]
	# returns 1 if answer is always true
	# returns empty list if it doesn't combine
	# returns empty list in list if proof
	# returns list of result(s) otherwise, should be always just one though
	similarities = [abs(a) for a in set(current).intersection(set([-a for a in clause]))]
	if len(similarities) == 0:
		return []
	if len(similarities) > 1:
		return 1
	answ = set()
	for x in current + clause:
		if abs(x) not in similarities:
			answ.add(x)
	return [list(answ)]


def resolution_solver(KB, neg_alpha):
	# KB: list of known clauses
	#           clause example: a v b v -c v d
	#           xys is representation. x and y are coordinates and s is state.
	#           s can be 0 (nothing), 1 (smell), 2 (breeze), 3 (beast), 4 (pit), 5 (glitter). Negative number for neg state
	# neg_alpha: query clause, already negated
	# returns True if proof found, False otherwise

	# initialize
	todo = [neg_alpha]
	done = KB.copy()

	# process the todo list one by one
	while todo:
		current = todo.pop()

		# check if current is redundant
		f = False
		for clause in done + todo:
			f = False
			for item in clause:
				if item not in current:
					f = True
					break
			if not f:
				break
		if not f:
			continue

		# combine current clause with all clauses we've already seen
		for clause in done:
			# apply resolution rule
			resolvents = resolve(current, clause)

			# 2. resolvent is always true: throw it away, useless clause
			if resolvents == 1:
				continue
			# handle new clauses generated by the resolution rule
			for resolvent in resolvents:
				# 1. resolvent is empty: proof found that KB->alpha!
				if not resolvent:
					return True
				# ONLY if neither of these things happen:
				todo.append(resolvent)

		# we're done with this clause
		done.append(current)

	# loop ended without proof
	return False


def generate_rules():
	moves = [(1, 0), (0, 1), (-1, 0), (0, -1)]
	rules = []
	for x in range(1, 6):
		for y in range(1, 6):
			for z in [1, 2]:
				pos = x * 100 + y * 10 + z
				neighbours = []
				for move in moves:
					x2 = x + move[0]
					y2 = y + move[1]
					if 0 < x2 < 6 and 0 < y2 < 6:
						neighbours.append(x2 * 100 + y2 * 10 + z + 2)
				rules.append([-pos] + neighbours)
				for neighbour in neighbours:
					rules.append([pos, -neighbour])
	return rules


def add_data(KB: list, x, y, listofstates):
	possiblestates = {1, 2, 3, 4}
	listofstates = set(listofstates)
	KB.extend([[x * 100 + y * 10 + a] for a in listofstates])
	KB.extend([[-(x * 100 + y * 10 + a)] for a in possiblestates.difference(listofstates)])

# KB = [  # 1P, 2Q, 3L, 4M, 5B, 6A
# 	[-1, 2],
# 	[-3, -4, 1],
# 	[-5, -3, 4],
# 	[-6, -1, 3],
# 	[-6, -5, 3],
# 	# [6],
# 	[5]
# ]
#
# neg = [-2]

# print(resolution_solver(KB, neg))

KB = generate_rules()
print(len(KB))
#  1 (smell), 2 (breeze), 3 (beast), 4 (pit), 5 (glitter). Negative number for neg state
add_data(KB, 1, 1, [])
add_data(KB, 1, 2, [2])
add_data(KB, 2, 2, [1])
add_data(KB, 2, 1, [2])
add_data(KB, 3, 2, [2])
add_data(KB, 3, 3, [1])
add_data(KB, 4, 2, [])

print("Pos 1, 3 has pit?", resolution_solver(KB, [-134]))
print("Pos 1, 3 has beast?", resolution_solver(KB, [-133]))
print("Pos 2, 3 has pit?", resolution_solver(KB, [-234]))
print("Pos 2, 3 has beast?", resolution_solver(KB, [-233]))
print("Pos 3, 4 has pit?", resolution_solver(KB, [-344]))
print("Pos 3, 4 has beast?", resolution_solver(KB, [-343]))
print("Pos 4, 3 has pit?", resolution_solver(KB, [-434]))
print("Pos 4, 3 has beast?", resolution_solver(KB, [-433]))
print("Pos 3, 1 has pit?", resolution_solver(KB, [-314]))
print("Pos 3, 1 has beast?", resolution_solver(KB, [-313]))
print("Pos 4, 1 has pit?", resolution_solver(KB, [-414]))
print("Pos 4, 1 has beast?", resolution_solver(KB, [-413]))
print("Pos 4, 1 has breeze?", resolution_solver(KB, [-412]))
print("Pos 4, 1 has smell?", resolution_solver(KB, [-411]))
print()
print("Is pos 1 3 safe?", resolution_solver(KB, [133, 134]))
print("Is pos 2 3 safe?", resolution_solver(KB, [233, 234]))
print("Is pos 3 4 safe?", resolution_solver(KB, [343, 344]))
print("Is pos 4 3 safe?", resolution_solver(KB, [433, 434]))
print("Is pos 3 1 safe?", resolution_solver(KB, [313, 314]))
print("Is pos 4 1 safe?", resolution_solver(KB, [413, 414]))


